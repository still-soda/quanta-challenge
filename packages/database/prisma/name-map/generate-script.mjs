import { parsePrismaSchema } from '@loancrate/prisma-schema-parser';
import { program } from 'commander';
import fs from 'fs/promises';
import path from 'path';

program
   .description('‰ΩøÁî® Prisma schema ÁîüÊàêË°®ÂêçÊò†Â∞ÑÁöÑ TypeScript Êñá‰ª∂')
   .option(
      '-o, --output <output>',
      'ËæìÂá∫TSÊñá‰ª∂',
      './prisma/name-map/_output.ts'
   )
   .option(
      '-s, --schema <schema>',
      'ËæìÂÖ•Prisma schemaÊñá‰ª∂',
      'prisma/schema.prisma'
   );
program.parse();

const opts = program.opts();
const schemaPath = path.resolve(process.cwd(), opts.schema);
const outputPath = path.resolve(process.cwd(), opts.output);

// ËØªÂèñÂπ∂Ëß£Êûê Prisma schema
const schema = await fs.readFile(schemaPath, 'utf-8');
const ast = parsePrismaSchema(schema);

// ÊèêÂèñÊâÄÊúâÊ®°ÂûãÂèäÂÖ∂Êò†Â∞ÑÂêçÁß∞
const models = ast.declarations.filter((node) => node.kind === 'model');
const nameMapping = models.map((model) => {
   const blockAttr = model.members.find(
      (m) => m.kind === 'blockAttribute' && m.path.value[0] === 'map'
   );
   return {
      modelName: model.name.value,
      realName: blockAttr ? blockAttr.args[0].value : model.name.value,
   };
});
const modelNamesSet = new Set(nameMapping.map((m) => m.modelName));

// ÈÄíÂΩíËß£ÊûêÂ≠óÊÆµÁ±ªÂûãÔºåÂ§ÑÁêÜ optional Âíå list
const recursiveFindTypeId = (
   obj,
   temp = { isOptional: false, isList: false, typeId: null }
) => {
   if (obj.kind === 'optional') {
      return recursiveFindTypeId(obj.type, { ...temp, isOptional: true });
   } else if (obj.kind === 'list') {
      return recursiveFindTypeId(obj.type, { ...temp, isList: true });
   }
   return { ...temp, typeId: obj.name.value };
};

// ÁîüÊàêÂµåÂ•óÊ®°ÂûãÂÖ≥Á≥ªÊò†Â∞Ñ
const nestedModelRelations = models.flatMap((model) => {
   const mapping = model.members
      .filter((m) => m.kind === 'field')
      .map((field) => {
         const typeInfo = recursiveFindTypeId(field.type);
         if (!modelNamesSet.has(typeInfo.typeId)) {
            return null;
         }

         let relationText = `${model.name.value}.${field.name.value}::${typeInfo.typeId}`;
         if (typeInfo.isList) {
            relationText += ':List:Required';
         } else if (typeInfo.isOptional) {
            relationText += ':Single:Optional';
         } else if (typeInfo.isList && typeInfo.isOptional) {
            relationText += ':List:Optional';
         } else {
            relationText += ':Single:Required';
         }

         return relationText;
      })
      .filter((x) => x !== null);

   return mapping;
});
const nestedModelMapping = nestedModelRelations.reduce((acc, cur) => {
   const [_field, model] = cur.split('::');
   const [owner, field] = _field.split('.');
   if (!acc[owner]) {
      acc[owner] = {};
   }
   acc[owner][field] = model;
   return acc;
}, {});

// ÁîüÊàêÊò†Â∞ÑÊñá‰ª∂ÂÜÖÂÆπ
const schemaToRealMap = nameMapping.reduce((acc, cur) => {
   acc[cur.modelName] = cur.realName;
   return acc;
}, {});
const realToSchemaMap = nameMapping.reduce((acc, cur) => {
   acc[cur.realName] = cur.modelName;
   return acc;
}, {});
const realNameFieldMap = models.reduce((acc, model) => {
   acc[schemaToRealMap[model.name.value]] = model.members
      .filter((m) => m.kind === 'field')
      .map((f) => f.name.value);
   return acc;
}, {});

// ËæìÂá∫TSÊñá‰ª∂
const outputContent = `// This file is auto-generated by prisma/name-map/generate-script.mjs
// Do not edit this file directly.

export const schemaToRealMap = ${JSON.stringify(
   schemaToRealMap,
   null,
   3
)} as const;
export const realToSchemaMap = ${JSON.stringify(
   realToSchemaMap,
   null,
   3
)} as const;

export const validRealNames = ${JSON.stringify(
   Object.keys(realToSchemaMap)
)} as const;

export const realNameFieldsMap = {${Object.entries(realNameFieldMap)
   .map(
      ([realName, fields]) =>
         `\n   "${realName}": new Set(${JSON.stringify(fields)} as const)`
   )
   .join(',')}} as const;

export const validRealNameFields = ${JSON.stringify(
   Object.entries(realNameFieldMap).reduce((acc, [realName, fields]) => {
      fields.forEach((field) => {
         acc.push(`${realName}.${field}`);
      });
      return acc;
   }, [])
)} as const;

export type SchemaToRealMap = typeof schemaToRealMap;
export type RealToSchemaMap = typeof realToSchemaMap;

export type SchemaName = keyof SchemaToRealMap;
export type RealName = keyof RealToSchemaMap;

export const nestedModelMapping = ${JSON.stringify(
   nestedModelMapping,
   null,
   3
)} as const;

export type NestedModelPath = {
   [K in keyof typeof nestedModelMapping]: \`\${K & string}.\${keyof (typeof nestedModelMapping)[K] & string}\`;
}[keyof typeof nestedModelMapping];

export type NestedModelPathType = {
   [K in NestedModelPath]: K extends \`\${infer Model}.\${infer Field}\`
      ? Model extends keyof typeof nestedModelMapping
         ? Field extends keyof (typeof nestedModelMapping)[Model]
            ? (typeof nestedModelMapping)[Model][Field]
            : never
         : never
      : never;
}

export type NestedModalPathTypeRealName = {
   [K in NestedModelPath]: K extends \`\${infer Model}.\${infer Field}\`
      ? Model extends keyof typeof nestedModelMapping
         ? Field extends keyof (typeof nestedModelMapping)[Model]
            ? (typeof nestedModelMapping)[Model][Field] extends \`\${infer RealName}:\${string}:\${string}\`
               ? SchemaToRealMap[RealName & keyof SchemaToRealMap]
               : never
            : never
         : never
      : never;
};

export type NestedModalPathTypeIsList = {
   [K in NestedModelPath]: K extends \`\${infer Model}.\${infer Field}\`
      ? Model extends keyof typeof nestedModelMapping
         ? Field extends keyof (typeof nestedModelMapping)[Model]
            ? (typeof nestedModelMapping)[Model][Field] extends \`\${string}:List:\${string}\`
               ? true
               : false
            : never
         : never
      : never;
};

export type NestedModalPathTypeIsOptional = {
   [K in NestedModelPath]: K extends \`\${infer Model}.\${infer Field}\`
      ? Model extends keyof typeof nestedModelMapping
         ? Field extends keyof (typeof nestedModelMapping)[Model]
            ? (typeof nestedModelMapping)[Model][Field] extends \`\${string}:\${string}:Optional\`
               ? true
               : false
            : never
         : never
      : never;
};

export type NestedModalPathTypeIsRequired = {
   [K in NestedModelPath]: K extends \`\${infer Model}.\${infer Field}\`
      ? Model extends keyof typeof nestedModelMapping
         ? Field extends keyof (typeof nestedModelMapping)[Model]
            ? (typeof nestedModelMapping)[Model][Field] extends \`\${string}:\${string}:Required\`
               ? true
               : false
            : never
         : never
      : never;
}

export type ValidFieldPath = typeof validRealNameFields[number];
`;

await fs.mkdir(path.dirname(outputPath), { recursive: true });
await fs.writeFile(outputPath, outputContent, 'utf-8');
console.log(`üéâ Name map generated at: ${outputPath}`);
